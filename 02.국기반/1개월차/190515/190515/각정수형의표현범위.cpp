#include<iostream>
using namespace std;


/*void main()
{
	// ##1. 각 정수 자료형의 표현 범위
	// ussigned char: 1byte(8bits) 2의 8승 => 256개의 수를 표현.
	// 0 ~ 255 까지 표현 가능.

	// signed char : 1byte(8bits) 2의 8승 => 256개의 수를 표현.
	// -128 ~ 127 까지 표현 가능.

	// unsigned short : 2byte(16bits) 2의 16승 => 65536개의 수를 표현.
	// 0 ~ 65535 까지 표현 가능.

	// signed short : 2byte(16bits) 2의 16승 => 65536개의 수를 표현.
	// -32768 ~ 32767 까지 표현 가능.

	// unsigned int : 4byte(32bits) 2의 32승 => 4,294,967,296개의 수를 표현.
	// 0 ~ 4,294,967,295 까지 표현 가능.

	// signed int : 4byte(32bits) 2의 32승 => 4,294,967,296개의 수를 표현.
	// -2,147,483,648 ~ 2,147,483,647  까지 표현 가능.

	// unsigned int : 8byte(64bits) 2의 64승 => 18,446,744,073,709,551,616개의 수를 표현.
	// 0 ~ 18,446,744,073,709,551,615까지 표현 가능.

	// signed int : 8byte(64bits) 2의 64승 => 18,446,744,073,709,551,616개의 수를 표현.
	// ‭9,223,372,036,854,775,808‬ ~ ‭9,223,372,036,854,775,807까지 표현 가능.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// ##2. 실수 표현 방식 (실수는 unsigned가 없다.)
	// 부동 소수점 방식으로 실수를 표현한다.
	// float(4byte) : 소수점 포함 7 ~ 8 자리까지 실수 표현 가능.
	// double(8byte) : 소수점 포함 15 ~ 16 자리까지 실수 표현 가능.
	// 따라서, double이 더 정밀한 실수를 표현 할 수 있다.

	// 32767 -> 0111 1111 1111 1111
	// 32768 -> 1000 1000 1000 1000

	// short 로 나타낼 경우 
	// 32767은 정상범위내 이기에 정상으로 나오지만
	// 32768은 정상범위에 벗어나기 때문에 -32768이 나온다.
	// 따라서 변수에 따르는 범위를 어느정도 알고 있어야 
	// 이러한 문제의 발생빈도를 줄일 수 있다.


	
}*/